steps:
  # Step 1: Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}:latest'
      - '-t'
      - 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}:$SHORT_SHA'
      - '.'

  # Step 2: Push image to Container Registry
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}'
      - '--all-tags'

  # Step 3: Ensure Cloud NAT exists for VPC egress internet access (idempotent)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        ROUTER="${_VPC_ROUTER}"
        NAT="${_VPC_NAT}"
        NETWORK="${_VPC_NETWORK}"

        # Create router if missing
        if ! gcloud compute routers describe "$${ROUTER}" \
            --region=${_REGION} --project=$PROJECT_ID &>/dev/null; then
          echo "Creating Cloud Router: $${ROUTER}"
          gcloud compute routers create "$${ROUTER}" \
            --region=${_REGION} \
            --network="$${NETWORK}" \
            --project=$PROJECT_ID
        else
          echo "Cloud Router $${ROUTER} already exists"
        fi

        # Create NAT config if missing
        if ! gcloud compute routers nats describe "$${NAT}" \
            --router="$${ROUTER}" \
            --region=${_REGION} --project=$PROJECT_ID &>/dev/null; then
          echo "Creating Cloud NAT: $${NAT}"
          gcloud compute routers nats create "$${NAT}" \
            --router="$${ROUTER}" \
            --region=${_REGION} \
            --auto-allocate-nat-external-ips \
            --nat-all-subnet-ip-ranges \
            --project=$PROJECT_ID
        else
          echo "Cloud NAT $${NAT} already exists"
        fi

  # Step 4: Deploy to Cloud Run with dynamic URLs
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Get master-agent URL dynamically
        AGENT_URL=$(gcloud run services describe ${_MASTER_AGENT_SERVICE} \
          --region=${_REGION} \
          --format='value(status.url)' 2>/dev/null || echo "")

        if [ -z "$${AGENT_URL}" ]; then
          echo "WARNING: master-agent service not found, using empty AGENT_API_URL"
          AGENT_URL=""
        fi
        echo "Master agent URL: $${AGENT_URL}"

        # Deploy service
        gcloud run deploy ${_SERVICE_NAME} \
          --image gcr.io/$PROJECT_ID/${_SERVICE_NAME}:$SHORT_SHA \
          --region ${_REGION} \
          --platform managed \
          --allow-unauthenticated \
          --network=default \
          --subnet=default \
          --vpc-egress=all-traffic \
          --set-secrets TELEGRAM_BOT_TOKEN=TELEGRAM_BOT_TOKEN:latest \
          --set-env-vars "LOG_LEVEL=INFO,AGENT_API_URL=$${AGENT_URL}"

        # Get deployed service URL
        SERVICE_URL=$(gcloud run services describe ${_SERVICE_NAME} \
          --region=${_REGION} \
          --format='value(status.url)')
        echo "Service URL: $${SERVICE_URL}"

        # Update with TELEGRAM_WEBHOOK_URL (triggers new revision but quick)
        gcloud run services update ${_SERVICE_NAME} \
          --region ${_REGION} \
          --update-env-vars "TELEGRAM_WEBHOOK_URL=$${SERVICE_URL}"

        # Grant bot SA invoker role on master-agent (idempotent)
        BOT_SA=$(gcloud run services describe ${_SERVICE_NAME} \
          --region=${_REGION} \
          --format='value(spec.template.spec.serviceAccountName)')
        if [ -n "$${BOT_SA}" ]; then
          gcloud run services add-iam-policy-binding ${_MASTER_AGENT_SERVICE} \
            --project=$PROJECT_ID \
            --region=${_REGION} \
            --member="serviceAccount:$${BOT_SA}" \
            --role=roles/run.invoker \
            --quiet
          echo "Granted roles/run.invoker on ${_MASTER_AGENT_SERVICE} to $${BOT_SA}"
        fi

        echo "Deploy complete with dynamic URLs"

  # Step 4: Setup Telegram webhook via API
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Get service URL
        SERVICE_URL=$(gcloud run services describe ${_SERVICE_NAME} \
          --region=${_REGION} \
          --format='value(status.url)')

        echo "Service URL: $${SERVICE_URL}"

        # Get bot token from Secret Manager (extract clean token format)
        BOT_TOKEN=$(gcloud secrets versions access latest --secret=TELEGRAM_BOT_TOKEN 2>/dev/null | grep -oE '[0-9]+:[A-Za-z0-9_-]+' | head -1)

        if [ -z "$${BOT_TOKEN}" ]; then
          echo "WARNING: Could not retrieve bot token. Webhook not set."
          exit 0
        fi

        # Derive webhook secret (sha256 of token, first 32 chars)
        WEBHOOK_SECRET=$(printf '%s' "$${BOT_TOKEN}" | sha256sum | cut -c1-32)

        # Webhook URL
        WEBHOOK_URL="$${SERVICE_URL}/telegram/webhook"
        echo "Webhook URL: $${WEBHOOK_URL}"

        # Set webhook with secret_token
        RESPONSE=$(curl -sf -X POST "https://api.telegram.org/bot$${BOT_TOKEN}/setWebhook" \
          -H "Content-Type: application/json" \
          -d "{\"url\": \"$${WEBHOOK_URL}\", \"secret_token\": \"$${WEBHOOK_SECRET}\"}" || echo '{"ok":false}')

        echo "Response: $${RESPONSE}"

        if echo "$${RESPONSE}" | grep -q '"ok"' && echo "$${RESPONSE}" | grep -q 'true'; then
          echo "Webhook set successfully"
        else
          echo "WARNING: Webhook setup may have failed"
        fi

        exit 0

# Substitution variables with defaults
substitutions:
  _REGION: 'europe-west4'
  _SERVICE_NAME: 'telegram-bot'
  _MASTER_AGENT_SERVICE: 'master-agent'
  _VPC_NETWORK: 'default'
  _VPC_ROUTER: 'nat-router'
  _VPC_NAT: 'nat-config'

# Build options
options:
  logging: CLOUD_LOGGING_ONLY

# Images to push
images:
  - 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}:latest'
  - 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}:$SHORT_SHA'
